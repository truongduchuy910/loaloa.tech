import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';
import { DateTime } from 'luxon';
import { Implementation, DateTime as DateTime$1 } from '@keystonejs/fields';
import { KnexFieldAdapter } from '@keystonejs/adapter-knex';
import { MongooseFieldAdapter } from '@keystonejs/adapter-mongoose';

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

class DateTimeUtcImplementation extends Implementation {
  constructor() {
    super(...arguments);
    this.isOrderable = true;
  }

  gqlOutputFields() {
    return ["".concat(this.path, ": String")];
  }

  gqlOutputFieldResolvers() {
    return {
      ["".concat(this.path)]: item => item[this.path] && item[this.path].toISOString()
    };
  }

  gqlQueryInputFields() {
    return [...this.equalityInputFields('String'), ...this.orderingInputFields('String'), ...this.inInputFields('String')];
  }

  get gqlUpdateInputFields() {
    return ["".concat(this.path, ": String")];
  }

  get gqlCreateInputFields() {
    return ["".concat(this.path, ": String")];
  }

  getGqlAuxTypes() {
    return ["scalar String"];
  }

  extendAdminMeta(meta) {
    return _objectSpread({}, meta, {
      format: 'YYYY-MM-DD[T]HH:mm:ss.SSSZZ'
    });
  }

} // All values must have an offset


const toDate = str => {
  if (!str.match(/([zZ]|[\+\-][0-9]+(\:[0-9]+)?)$/)) {
    throw "Value supplied (".concat(str, ") is not a valid date time with offset.");
  }

  return DateTime.fromISO(str).toJSDate();
};

class MongoDateTimeUtcInterface extends MongooseFieldAdapter {
  addToMongooseSchema(schema) {
    schema.add({
      [this.path]: this.mergeSchemaOptions({
        type: Date
      }, this.config)
    });
  }

  getQueryConditions(dbPath) {
    return _objectSpread({}, this.equalityConditions(dbPath, toDate), {}, this.orderingConditions(dbPath, toDate), {}, this.inConditions(dbPath, toDate));
  }

}

class KnexDateTimeUtcInterface extends KnexFieldAdapter {
  constructor() {
    super(...arguments);
    this.isUnique = !!this.config.isUnique;
    this.isIndexed = !!this.config.isIndexed && !this.config.isUnique;
  }

  addToTableSchema(table) {
    // It's important we don't exceed the precision of native Date
    // objects (ms) or JS will silently round values down.
    const column = table.timestamp(this.path, {
      useTz: true,
      precision: 3
    });
    if (this.isUnique) column.unique();else if (this.isIndexed) column.index();
    if (this.isNotNullable) column.notNullable();
    if (this.defaultTo) column.defaultTo(this.defaultTo);
  }

  getQueryConditions(dbPath) {
    return _objectSpread({}, this.equalityConditions(dbPath, toDate), {}, this.orderingConditions(dbPath, toDate), {}, this.inConditions(dbPath, toDate));
  }

}

const DateTimeUtc = {
  type: 'DateTimeUtc',
  implementation: DateTimeUtcImplementation,
  views: {
    Controller: DateTime$1.views.Controller,
    Field: DateTime$1.views.Field,
    Filter: DateTime$1.views.Filter,
    Cell: DateTime$1.views.Cell
  },
  adapters: {
    mongoose: MongoDateTimeUtcInterface,
    knex: KnexDateTimeUtcInterface
  }
};
export { DateTimeUtc };
